# 全排列

> 从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。

> 公式：全排列数f(n)=n!(定义0!=1)

## 递归算法实现

1. 基本思想： 
   + 把待全排列记录分为两个部分： 
      + 第一个记录 
      + 剩下的所有元素 
所有记录的全排列就是所有可能出现在第一个位置的记录与剩下所有元素的全排列。
``` 
以[1,2,3]为例，
1,2,3的全排列可以看作是 
   1,[2,3的全排列] 
      [2,3]的全排列又可以看作是 
         2,[3的全排列]—————对应123 
         3,[2的全排列]—————对应132 
   2,[1,3的全排列] 
      [1,3]的全排列又可以看作是 
         1,[3的全排列]—————对应213 
         3,[1的全排列]—————对应231 
   3,[1,2的全排列] 
      [1,2]的全排列又可以看作是 
         1,[2的全排列]—————对应312 
         2,[1的全排列]—————对应321
```

所以很明显，这就是一个递归的思想：给你部分记录，全排列就是所有可能出现在第一个位置的记录与剩下的元素的全排列，剩下的元素的全排列又是剩下的可能出现在第一个位置的元素与剩下的元素的全排列，依次重复下去….

2. 代码实现

+ fullSort方法接收三个参数，数组arr，起始位置start，终止为止end，意思就是完成arr数组从start到end之间记录的全排列。 
   + 分两个步骤： 
      + 确定第一位的字符 
         + 数组arr从start到end的所有记录都可以出现在第一个位置，所以直接一个for循环，考虑了这所有的情况。在for循环中，swap方法就是交换i和start位置的数，保证当前i指向的记录出现在第一个位置，也就是start指向的位置 
      + 剩下的记录继续做全排列 
         + 这个就是一个递归函数的调用，只需要修改起始位置，也就是start+1，因为start的位置已经放了记录，所以只需要继续做从start+1到end的全排列即可

+ 至于紧接着的一个swap方法是做什么的呢？因为数组传递的是地址，所以所有的修改对所有人都是共享的，因此为了保证每一次的交换不会对下一次的交换产生影响，要重新交换一下位置，也就是复原，不然对下一次的交换就有影响了

+ 递归的终止条件就是当start==end，也就是只有一个记录需要做全排列，也就是到了最后一个记录，这就是全排列的一种情况，输入本次的记录，也就是数组arr即可。

```java
public class Main {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4 };
        fullSort(arr, 0, arr.length - 1);
    }

    public static void fullSort(int[] arr, int start, int end) {
        // 递归终止条件
        if (start == end) {
            for (int i : arr) {
                System.out.print(i);
            }
            System.out.println();
            return;
        }
        for (int i = start; i <= end; i++) {
            swap(arr, i, start);
            fullSort(arr, start + 1, end);
            swap(arr, i, start);
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

}
```

## 应用实例

